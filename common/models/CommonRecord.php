<?php

namespace reketaka\helps\common\models;

use reketaka\helps\common\behaviors\AliasBehavior;
use reketaka\helps\common\helpers\Bh;
use Yii;
use yii\base\Exception;
use yii\behaviors\TimestampBehavior;
use yii\db\ActiveRecord;
use yii\helpers\ArrayHelper;
use yii\helpers\Html;
use yii\helpers\StringHelper;
use yii\log\Logger;
use function array_merge;

class CommonRecord extends ActiveRecord{

    public $behaviorAlias = false;
    public $behaviorAliasEvent = ActiveRecord::EVENT_BEFORE_VALIDATE;

    public $behaviorTimestamp = false;

    /**
     * Время кеширования для вызова функции getBy
     * @var int
     */
    public $cacheOneTime = 3600;

    public function behaviors()
    {
        $behaviors = parent::behaviors();
        if ($this->behaviorTimestamp) {
            $behaviors = array_merge($behaviors, [
                [
                    'class' => TimestampBehavior::class,
                    'value' => \Yii::$app->formatter->asDatetime(time(), \Yii::$app->params['dateControlSave'][\kartik\datecontrol\Module::FORMAT_DATETIME]),
                ]
            ]);
        }

        if ($this->behaviorAlias) {
            $behaviors = array_merge($behaviors, [
                [
                    'class' => AliasBehavior::class,
                    'event' => $this->behaviorAliasEvent
                ]
            ]);

        }

        return $behaviors; // TODO: Change the autogenerated stub
    }

    /**
     * Пытается для найти дочерную модель по переданным данным $data.
     * В противном случае создает этуже модель использую этиже данные
     * @param $data
     * @param $validateAndSave
     * @return CommonRecord|null|static
     */
    public static function getOrCreate($data, $validateAndSave = true){
        if($elem = static::findOne($data)){
            return $elem;
        }

        $elem = new static();
        $elem->attributes = $data;

        if($validateAndSave) {
            if (!$elem->validate()) {
                \Yii::error($elem->errors, __METHOD__);
                throw new Exception(implode(' ', $elem->getFirstErrors()));
            }
            $elem->save();
        }

        return $elem;
    }

    /**
     * Аналог функции findAll только результаты кушируются
     * @param $data
     * @return CommonRecord|array|null|ActiveRecord
     */
    public static function getBy($data){
        if(!is_array($data)){
            return static::find()->cache(0)->where(['id'=>$data])->one();
        }

        return static::find()->where($data)->cache()->one();
    }

    public static function getsBy($data){
        return static::find()->where($data)->cache()->all();
    }

    public static function basename(){
        return StringHelper::basename(static::class);
    }

    public static function bn(){
        return self::basename();
    }

    public function beforeSave($insert)
    {
        if (!parent::beforeSave($insert)) {
            return false;
        }

        if($insert && \Yii::$app->id != 'app-console'){
            $this->markOwner();
        }

        return true;
    }

    /**
     * При создании модели отмечает владельца (создателя)
     */
    public function markOwner(){

        if(!array_key_exists('owner_id', $this->attributes) || \Yii::$app->user->isGuest){
            return false;
        }

        $userId = \Yii::$app->user->getId();

        $this->owner_id = $userId;

    }

    /**
     * Возвращает модель хозяина модели
     * @return bool|User|null
     */
    public function owner(){
        if(!array_key_exists('owner_id', $this->attributes) || \Yii::$app->user->isGuest){
            return null;
        }

        return User::findOne(['user_id'=>$this->owner_id]);
    }

    /**
     * Если есть ошибки валидации записывает их в лог
     */
    public function ifErrorLog(){
        if($this->hasErrors()){
            \Yii::getLogger()->log($this->errors, Logger::LEVEL_TRACE);
        }
    }

    public function strictSave($runValidation = true, $attributeNames = null)
    {
        if($this->save($runValidation, $attributeNames)){
            return true;
        }

        $className = static::basename();
        Yii::error(["Couldn't save $className object", $this->attributes, $this->errors]);
        throw new Exception("Error on model saving $className");
    }

    public static function strictFindOne($condition){
        if(!$model = static::findOne($condition)){
            Yii::error(['message'=>"Not found ".static::bn(), 'condition'=>$condition], __METHOD__);
            throw new Exception("Not found ".static::bn());
        }

        return $model;
    }

    /**
     * Проверяет есть ли ошибки в валидации если есть вешает список всех ошибок в session flash error
     * @return bool
     */
    public function hasErrorsFlash(){

        if(!$this->hasErrors()){
            return false;
        }

        Yii::$app->session->setFlash('error', $this->getErrorsString('</br>'));
        return true;
    }

    public function getErrorsString($delemiter = ', '){

        $text = [];
        foreach($this->getErrors() as $attribute=>$errors){
            $text[] = implode($delemiter, $errors);
        }
        return implode($delemiter, $text);
    }

    public static function findOneForUpdate($whereData) {
        $sql = self::find()
            ->where($whereData)
            ->createCommand()
            ->getRawSql();

        return self::findBySql($sql . ' FOR UPDATE')->one();
    }


    /**
     * @return array
     */
    public static function getArrayMap($key = 'id', $value = 'title'){
        $items = static::find()->select([$key, $value])->asArray()->all();
        return ArrayHelper::map($items, $key, $value);
    }

    public function flashMessage($msg, $type = 'success'){
        Yii::$app->session->setFlash($type, $msg);
        return true;
    }

    /**
     * Возвращает ссылку на элемент в фронте
     * @throws Exception
     */
    public function getFrontUrl(){
        throw new Exception("FrontUrl not set");
    }

    /**
     * Возвращает название модели для фронта
     * @return mixed|null
     */
    public function getFrontTitle(){
        return $this->title??null;
    }

    /**
     * Возвращает ссылку на модель фронт
     * @param string[] $options
     * @return string
     * @throws Exception
     */
    public function getFrontLink($options = ['target' => '_blank'])
    {
        $encodedTitle = Html::encode($this->getFrontTitle());
        return Html::a($encodedTitle, $this->getFrontUrl(), $options);
    }

    /**
     * Возвращает ссылку на элемент в админке
     * @throws Exception
     */
    public function getBackendViewUrl(){
        throw new Exception("BackendUrl not set");
    }

    /**
     * Добавляет правила
     * ```
     * intStringRequired
     * [[$attribute], 'required'],
     * [[$attribute], 'string', 'max'=>255],
     * [[$attribute], 'filter', 'filter'=>'trim'],
     * [[$attribute], 'reketaka\helps\common\validators\OnlyInteger'],
     *
     * boolean
     * [[$attribute], 'integer', 'min'=>0, 'max'=>1],
     * [[$attribute], 'default', 'value'=>0],
     * ```
     *
     * @param $rules
     * @param $attribute
     * @param $type
     * @return bool
     */
    public function addRule(&$rules, $attributes, $type){

        if(!is_array($attributes)){
            $attributes = [$attributes];
        }

        if($type == 'stringRequired') {
            foreach($attributes as $attribute) {
                $rules = array_merge($rules, [[[$attribute], 'required']]);
                $rules = array_merge($rules, [[[$attribute], 'string', 'max' => 255]]);
                $rules = array_merge($rules, [[[$attribute], 'filter', 'filter' => 'trim']]);
                $rules = array_merge($rules, [[[$attribute], 'filter', 'filter' => 'mb_strtolower']]);
            }
        }

        if($type == 'intStringRequired') {
            foreach($attributes as $attribute) {
                $rules = array_merge($rules, [[[$attribute], 'reketaka\helps\common\validators\OnlyInteger']]);
                $rules = array_merge($rules, [[[$attribute], 'required']]);
                $rules = array_merge($rules, [[[$attribute], 'string', 'max' => 255]]);
                $rules = array_merge($rules, [[[$attribute], 'filter', 'filter' => 'trim']]);
            }
        }

        if($type == 'intString') {
            foreach($attributes as $attribute) {
                $rules = array_merge($rules, [[[$attribute], 'string', 'max' => 255]]);
                $rules = array_merge($rules, [[[$attribute], 'filter', 'filter' => 'trim']]);
                $rules = array_merge($rules, [[[$attribute], 'reketaka\helps\common\validators\OnlyInteger']]);
            }
        }

        if($type == 'text') {
            foreach($attributes as $attribute) {
                $rules = array_merge($rules, [[[$attribute], 'string']]);
                $rules = array_merge($rules, [[[$attribute], 'default', 'value' => null]]);
            }
        }

        if($type == 'boolean'){
            foreach($attributes as $attribute) {
                $rules = array_merge($rules, [[[$attribute], 'integer', 'min' => 0, 'max' => 1]]);
                $rules = array_merge($rules, [[[$attribute], 'default', 'value' => 0]]);
            }
        }

        if($type == 'dateTimestamp'){
            foreach($attributes as $attribute) {
                $rules = array_merge($rules,
                    [[[$attribute], 'datetime', 'format' => 'php:Y-m-d H:i', 'timestampAttribute' => $attribute]]);
            }
        }
        return true;
    }
}