<?php

namespace reketaka\helps\common\models;


use common\helpers\BaseHelper;
use yii\db\ActiveRecord;

class Regedit extends ActiveRecord{

    private $storage;

    public static function tableName()
    {
        return 'regedit';
    }

    public function rules(){
        return [
            [['var', 'val'], 'string'],
            [['rel'], 'integer'],
            [['rel'], 'default', 'value' => 0]
        ];
    }

    public function init()
    {
        parent::init(); // TODO: Change the autogenerated stub
    }

    /**
     * Возвращает значение пути реестра
     * @param string $path путь реестра
     * @return string
     */
    public function get($path){
        $path = trim($path, '/');

        if (!$this->contains($path)) {
            return null;
        }

        $registry = $this->getRegistry();
        $id = $registry[$path];
        $row = $registry[$this->getIdKey($id)];
        return $row['val'];

    }

    /**
     * Возвращает список значений реестра
     * @example $modules = $umiRegistry->getList('//modules');
     * @param string $path путь реестра
     * @return array
     */
    public function getList($path){
        if ($path !== '//' && !$this->contains($path)) {
            return [];
        }

        $registry = $this->getRegistry();
        $id = ($path == '//') ? 0 : $registry[trim($path, '/')];
        $row = isset($registry[$this->getIdKey($id)]) ? $registry[$this->getIdKey($id)] : [];
        $children = isset($row['children']) ? $row['children'] : [];
        $list = [];

        foreach ($children as $childId) {
            $childRow = $registry[$this->getIdKey($childId)];
            $list[] = [
                $childRow['var'],
                $childRow['val'],
            ];
        }

        return $list;

    }

    /**
     * Записывает значение в реестр
     * @param string $path путь реестра
     * @param string $value значение
     * @return bool true
     */
    public function set($path, $value){
        $value = (string) $value;
        $existValue = $this->get($path);

        if ($value === $existValue) {
            return true;
        }

        $keyId = $this->getKeyId($path);

        if($keyId === FALSE) {
            $keyId = $this->createKey($path);
        }

        \Yii::$app->db->createCommand()->update(self::tableName(), [
            'val'=>$value
        ], [
            'id'=>$keyId
        ])->execute();

        $registry = $this->getRegistry();
        $registry[$this->getIdKey($keyId)]['val'] = (string) $value;
        $this->saveRegistry($registry);

        return true;

    }

    /**
     * Удаляет значение в реестре
     * @param string $path путь реестра
     * @return bool
     */
    public function remove($path){
        $keyId = $this->getKeyId($path);

        if ($keyId === FALSE) {
            return false;
        }

        \Yii::$app->db->createCommand()->delete(self::tableName(), 'rel =:rel OR id =:rel', [':rel' => $keyId])->execute();
        $this->clearCache();

        return true;

    }

    /**
     * Очищает кеш
     * @return $this
     */
    public function clearCache(){
        return true;
        return $this->saveRegistry([]);
    }

    /**
     * Возвращает, есть ли в реестре значение по указанному пути
     * @param string $path путь реестра
     * @return bool
     */

    public function contains($path) {
        $path = trim($path, '/');
        return isset($this->getRegistry()[$path]);
    }

    /**
     * Сохраняет кеш реестра в хранилище
     * @param array $registry кеш реестра
     * @return $this
     */
    private function saveRegistry(array $registry) {

        return true;

        $this->getStorage()
            ->saveRawData('registry', $registry, time());
        return $this;
    }


    /**
     * Возвращает закешированный реестр.
     * Если реестр пуст - инициирует его загрузку.
     * @return array
     */
    private function getRegistry() {

        return $this->loadRegistry();


        $storage = $this->getStorage();
        $registry = (array) $storage->loadRawData('registry');

        if (empty($registry)) {
            $this->saveRegistry($this->loadRegistry());
        }

        return (array) $storage->loadRawData('registry');
    }

    /**
     * Возвращает хранилище кеша
     */
    public function getStorage() {
        return $this->storage;
    }

    /**
     * Загружает реестр
     * @return array
     */
    private function loadRegistry() {
        $result = self::find()
            ->orderBy('id')
            ->createCommand()
            ->queryAll();

        $registry = [];

        foreach($result as $row){
            $id = $row['id'];
            $parentId = $row['rel'];
            $parentIdKey = $this->getIdKey($parentId);

            if (isset($registry[$parentIdKey])) {
                $path = ($parentId == 0) ? $row['var'] : $registry[$parentIdKey]['path'] . '/' . $row['var'];
                $registry[$parentIdKey]['children'][] = $id;
            } else {
                $path = $row['var'];
                $registry[$parentId] = [
                    'id' => $parentId,
                    'children' => [
                        $id
                    ]
                ];
            }

            $row['path'] = $path;
            $row['children'] = [];
            $registry[$this->getIdKey($id)] = $row;
            $registry[$path] = $id;
        }

        return $registry;
    }

    /**
     * Возвращает ключ для идентификатора закешированного реестра
     * @param int $id идентификатор
     * @return string
     */
    private function getIdKey($id) {
        return sprintf('id_%d', $id);
    }

    /**
     * Возвращает идентификатор ключа реестра
     * @param string $path путь реестра
     * @return int|false
     */
    private function getKeyId($path) {
        $path = trim($path, '/');
        $keyId = 0;

        foreach (explode('/', $path) as $key) {

            if(!$result = self::find()->where(['rel'=>$keyId, 'var'=>$key])->createCommand()->queryOne()){
                return false;
            }

            $keyId = $result['id'];
        }

        return $keyId;
    }

    /**
     * Создает ключ реестра и возвращает его идентификатор
     * @param string $path путь реестра
     * @return int|null
     */
    protected function createKey($path) {
        $path = trim($path, '/');
        $subKeyPath = '//';

        $relId = 0;
        $keyId = null;

        foreach (explode('/', $path) as $key) {
            $subKeyPath .= $key . '/';
            $keyId = $this->getKeyId($subKeyPath);

            if ($keyId !== FALSE) {
                $relId = $keyId;
                continue;
            }

            $relId = (int) $relId;

            \Yii::$app->db->createCommand()->insert(self::tableName(), [
                'rel'=>$relId,
                'var'=>$key,
                'val'=>''
            ])->execute();

            $keyId = \Yii::$app->db->getLastInsertID();

            $registry = $this->getRegistry();
            $registry[$this->getIdKey($keyId)] = [
                'id' => $keyId,
                'var' => $key,
                'val' => null,
                'rel' => $relId,
                'children' => []
            ];

            $registry[trim($subKeyPath, '/')] = $keyId;
            $registry[$this->getIdKey($relId)]['children'][] = $keyId;
            $this->saveRegistry($registry);

            $relId = $keyId;
        }

        return $keyId;
    }











}